<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta content="text/javascript" http-equiv="content-script-type">
<title>pfft.pfft</title>
<link rel="stylesheet" type="text/css" href="candydoc/style.css">
<!--[if lt IE 7]><link rel="stylesheet" type="text/css" href="candydoc/ie56hack.css"><![endif]-->
<script language="JavaScript" src="candydoc/underscore-min.js" type="text/javascript"></script>
<script language="JavaScript" src="candydoc/jquery.min.js" type="text/javascript"></script>
<script language="JavaScript" src="candydoc/jquery.cookie.js" type="text/javascript"></script>
<script language="JavaScript" src="candydoc/util.js" type="text/javascript"></script>
<script language="JavaScript" src="candydoc/tree.js" type="text/javascript"></script>
<script language="JavaScript" src="candydoc/explorer.js" type="text/javascript"></script>
</head><body>
<div id="tabarea"></div>
<div id="explorerclient" class="shaded_box">
</div>
<div id="loadingdoc">Loading...</div>
<div id="content" class="shaded_box">
    <div id="docbody">
        <h2 class="moduletitle">pfft.pfft</h2>
        <!-- Generated by Ddoc from ../pfft/pfft.d -->
<br>

<dl>
<dt><span class="decl">class 
<span class="currsymbol">Fft</span>(T);
</span></dt>
<dd>A class for calculating discrete fourier transform. The methods of this class
use split format for complex data. This means that complex data set is
represented as two arrays - one for the real part and one for the imaginary
part. An instance of this class can only be used for transforms of one
particular size. The template parameter is the floating point type that the
methods of the class will operate on.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color="#008">import</font> std.stdio, std.conv, std.exception;
<font color="#008">import</font> pfft.pfft;

<font color="#008">void</font> main(string[] args)
{
    <font color="#008">auto</font> n = to!<font color="#008">int</font>(args[1]);
    enforce((n &amp; (n-1)) == 0, <font color="#A31515">"N must be a power of two."</font>);

    <font color="#008">alias</font> <u>Fft</u>!<font color="#008">float</font> F;

    <font color="#008">auto</font> f = <font color="#008">new</font> F(n);

    <font color="#008">auto</font> re = F.allocate(n);
    <font color="#008">auto</font> im = F.allocate(n);

    <font color="#008">foreach</font>(i, _; re)
        readf(<font color="#A31515">"%s %s\n"</font>, &amp;re[i], &amp;im[i]);

    f.fft(re, im);

    <font color="#008">foreach</font>(i, _; re)
        writefln(<font color="#A31515">"%s %s"</font>, re[i], im[i]);
}
</pre>
<br><br>


<dl>
<dt><span class="decl">this(size_t <span class="funcparam">n</span>);
</span></dt>
<dd>The Fft constructor. The parameter is the size of data sets that the fft() and
ifft() will operate on. Tables used in fft and ifft are calculated in the
constructor.<br><br>

</dd>

<dt><span class="decl">void 
<span class="currsymbol">fft</span>(T[] <span class="funcparam">re</span>, T[] <span class="funcparam">im</span>);
</span></dt>
<dd>Calculates discrete fourier transform. <i><span class="funcparam">re</span></i> should contain the real
part of the data and <i><span class="funcparam">im</span></i> the imaginary part of the data. The method
operates in place - the result is saved back to <i><span class="funcparam">re</span></i> and <i><span class="funcparam">im</span></i>.
Both arrays must be properly aligned - to get a properly aligned array you can
use allocate().<br><br>

</dd>

<dt><span class="decl">void 
<span class="currsymbol">ifft</span>(T[] <span class="funcparam">re</span>, T[] <span class="funcparam">im</span>);
</span></dt>
<dd>Calculates inverse discrete fourier transform scaled by n (where n is the
length of argument array). The arguments have the same role as they do in fft().<br><br>

</dd>

<dt><span class="decl">T[] 
<span class="currsymbol">allocate</span>(size_t <span class="funcparam">n</span>);
</span></dt>
<dd>Allocates an array that is aligned properly for use with fft() and ifft()
methods.<br><br>

</dd>
</dl>
</dd>

<dt><span class="decl">class 
<span class="currsymbol">Rfft</span>(T);
</span></dt>
<dd>A class for calculating real discrete fourier transform. The methods of this
class use split format for complex data. This means that complex data set is
represented as two arrays - one for the real part and one for the imaginary
part. An instance of this class can only be used for transforms of one
particular size. The template parameter is the floating point type that the
methods of the class will operate on.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color="#008">import</font> std.stdio, std.conv, std.exception;
<font color="#008">import</font> pfft.pfft;

<font color="#008">void</font> main(string[] args)
{
    <font color="#008">auto</font> n = to!<font color="#008">int</font>(args[1]);
    enforce((n &amp; (n-1)) == 0, <font color="#A31515">"N must be a power of two."</font>);

    <font color="#008">alias</font> <u>Rfft</u>!<font color="#008">float</font> F;

    <font color="#008">auto</font> f = <font color="#008">new</font> F(n);

    <font color="#008">auto</font> data = F.allocate(n);
    <font color="#008">auto</font> re = F.allocate(n / 2 + 1);
    <font color="#008">auto</font> im = F.allocate(n / 2 + 1);

    <font color="#008">foreach</font>(<font color="#008">ref</font> e; data)
        readf(<font color="#A31515">"%s\n"</font>, &amp;e);

    f.rfft(data, re, im);

    <font color="#008">foreach</font>(i, _; re)
        writefln(<font color="#A31515">"%s %s"</font>, re[i], im[i]);
}
</pre>
<br><br>


<dl>
<dt><span class="decl">this(size_t <span class="funcparam">n</span>);
</span></dt>
<dd>The Rfft constructor. The parameter is the size of data sets that rfft() will
operate on. Tables used in rfft are calculated in the constructor.<br><br>

</dd>

<dt><span class="decl">void 
<span class="currsymbol">rfft</span>(T[] <span class="funcparam">data</span>, T[] <span class="funcparam">re</span>, T[] <span class="funcparam">im</span>);
</span></dt>
<dd>Calculates discrete fourier transform of the real <span class="funcparam">data</span> in parameter <strong><code><span class="funcparam">data</span></code></strong>.
The method operates out of place - the result is saved to <strong><code><span class="funcparam">re</span></code></strong> and <strong><code><span class="funcparam">im</span></code></strong>
and the <span class="funcparam">data</span> in <strong><code><span class="funcparam">data</span></code></strong> isn't changed.
The length of <span class="funcparam">re</span> and <span class="funcparam">im</span> must be <strong><code><span class="funcparam">data</span>.length / 2 + 1</code></strong> - only the
first part of the discrete fourier transform is stored to <strong><code><span class="funcparam">re</span></code></strong> and <strong><code><span class="funcparam">im</span></code></strong>.
The remaining elements can be trivially calculated from the relation
 <i>DFT(f)[i] = adj(DFT(f)[n - i])</i> that holds when f is real.
All three arrays must be properly aligned - to get a properly aligned array
you can use <strong><code>allocate()</code></strong>.<br><br>

</dd>

<dt><span class="decl">alias 
<span class="currsymbol">allocate</span>;
</span></dt>
<dd>An alias for Fft!(TT).
<span class="currsymbol">allocate</span><br><br>

</dd>
</dl>
</dd>
</dl>

        <span id="docbody_end"/>
    </div>
</div>
<!--    <div id="docfooter">
            Page was generated with
            <a href="https://github.com/eldar/candydoc"><img src="candydoc/img/logo.png" style="vertical-align:middle; position:relative; top:-1px"></a>
            on Tue Jul  3 00:18:05 2012

        </td>-->
<span id="packages" class="emptytag">
	<span class="emptytag module" modulename="pfft.stdapi"></span>
	<span class="emptytag module" modulename="pfft.pfft"></span></span>
</body></html>


